Write Up CTF Holiday Bounty 2025
Write by Ndhoo

1. Silent Ping TBF1{1cmp_tunne1ing_is_n0t_stea1thy_enough}
Category: Network Forensics
File: silent_ping.pcap
Pada challenge ini, sebuah Intrusion Detection System (IDS) gagal mendeteksi aktivitas mencurigakan berupa lonjakan trafik ICMP. Server database internal diketahui mengirimkan ribuan ICMP Echo Request ke sebuah IP eksternal pada pukul 03.00 pagi. Karena ping adalah lalu lintas yang umum, aktivitas ini tidak langsung dianggap berbahaya.
Tujuan challenge adalah menyelidiki trafik ICMP tersebut dan menentukan data apa yang diselundupkan melalui payload ICMP.

Langkah pertama adalah mengidentifikasi jenis trafik dalam PCAP:
tshark -r silent_ping.pcap -Y "icmp"
Karena payload dikirim secara terfragmentasi dalam banyak paket, seluruh payload perlu digabung:
cat icmp_hex.txt | tr -d '\n' > all_hex.txt
Setelah digabung, dilakukan decoding dari hex ke biner:
xxd -r -p all_hex.txt decoded.bin
Isi file hasil decode dianalisis:
cat decoded.bin, didapatkan hasil:
@nerr96  cat decoded.bin
PingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataTBF1{1cmp_tunne1ing_is_n0t_stea1thy_enough}PingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalDataPingNormalData%                                                                        
ketemu flagnya itu formatnya TBF

2. SFR1 TBF1{r3scu1ng_9oph3r5_fr0m_flo0d5}
Sebuah gopher terjebak di dalam sarangnya yang kebanjiran data rusak. Ia berhasil mengirimkan satu foto terakhir, namun file tersebut terlihat glitch/garbled dan file rahasia tidak bisa dibuka. Tugas kita adalah menganalisis file gambar tersebut dan menemukan flag yang tersembunyi.
Langkah pertama dalam forensik file adalah memastikan tipe file sebenarnya.
file broke.jpg
JPEG image data, JFIF standard 1.01, baseline, 218x231
Outputnya JPEG image data, JFIF standard 1.01, baseline, 218x231, yang berarti file adalah JPEG valid, bukan ekstensi palsu.
Langkah kedua, karena file valid tetapi mencurigakan, dilakukan analisis struktur internal menggunakan binwalk.
binwalk broke.jpg
Outputnya:
DECIMAL       HEXADECIMAL     DESCRIPTION
---------------------------------------------------------
0                               0x0                    JPEG image data
30                            0x1E                   TIFF image data
19886                     0x4DAE              End of Zip archive, footer length: 22
Ditemukan ZIP footer (End of Zip archive). Namun tidak ditemukan header ZIP Ini menandakan ZIP sengaja dirusak / tidak lengkap. Oleh karena itu, binwalk -e gagal mengekstrak.
Langkah ketiga, lakukan string analysis. Karena ZIP rusak, langkah berikutnya adalah mencari plaintext yang mungkin bocor menggunakan strings.
strings -td broke.jpg | grep PK
19774 TBF1{r3scu1ng_9oph3r5_fr0m_flo0d5}PK
Maka didapatkan flagnya.

3. Flag Checker TBF1{py7h0n_m4k3s_tr4n5f0rm50_e4sy}
Langkah pertama adalah mengidentifikasi tipe file.
file flagcheckerv2
Outputnya: ELF 64-bit LSB executable, x86-64, dynamically linked
Binary flagcheckerv2 pertama kali dianalisis menggunakan perintah file flagcheckerv2 dan diketahui merupakan executable ELF 64-bit Linux. Analisis awal menggunakan strings flagcheckerv2 memperlihatkan string “Enter the flag:”, “Wrong!”, dan “Correct!”, yang mengindikasikan bahwa program ini berfungsi sebagai flag checker dengan mekanisme validasi internal. 
Analisis dinamis dilakukan menggunakan GNU Debugger dengan perintah gdb ./flagcheckerv2. Karena binary tidak memiliki simbol debug, eksekusi dimulai dari loader menggunakan starti. Untuk menemukan fungsi main, breakpoint dipasang pada __libc_start_main menggunakan break __libc_start_main, kemudian program dijalankan dengan continue. Saat breakpoint tercapai, register rdi diperiksa menggunakan info registers rdi karena register tersebut menyimpan alamat fungsi main. Breakpoint kemudian dipasang pada alamat tersebut menggunakan break *<alamat_main> dan eksekusi dilanjutkan.
Setelah berada di fungsi main, instruksi dianalisis menggunakan x/80i $pc. Dari hasil disassembly terlihat bahwa program mencetak prompt, membaca input menggunakan fgets, menghapus karakter newline, lalu memproses input dalam sebuah loop. Setiap karakter input dipanggilkan ke sebuah fungsi transformasi dan hasilnya dibandingkan dengan array byte statis di memori. Jika terjadi ketidaksesuaian, program mencetak “Wrong!” dan berhenti, sedangkan jika semua karakter sesuai, program mencetak “Correct!”.
Fungsi transformasi dianalisis dengan melakukan disassembly pada alamat pemanggilan fungsi menggunakan x/40i <alamat_fungsi>. Fungsi tersebut melakukan operasi XOR terhadap karakter input dengan nilai 0x67, kemudian memanggil fungsi lain yang berisi operasi bitwise. Disassembly fungsi kedua menggunakan x/40i <alamat_rotasi> menunjukkan operasi shift kanan satu bit dan shift kiri tujuh bit yang digabungkan dengan OR, yang merupakan implementasi dari operasi rotate right satu bit (ROR 1).
Array byte target yang digunakan sebagai pembanding diekstraksi langsung dari memori menggunakan perintah x/40xb <alamat_array>. Panjang array tersebut adalah 35 byte, sehingga dapat disimpulkan bahwa panjang flag yang valid adalah 35 karakter. Untuk mendapatkan flag asli, transformasi dibalik dengan melakukan rotate left satu bit (ROL 1) terhadap setiap byte target, kemudian di-XOR kembali dengan 0x67.
Proses pembalikan dilakukan menggunakan script Python sederhana untuk mengotomatisasi decoding seluruh byte target. Setelah flag berhasil direkonstruksi dan dimasukkan ke program, output yang dihasilkan adalah “Correct!”, yang menandakan bahwa flag yang diperoleh valid. Challenge ini menggunakan teknik obfuscation sederhana berbasis XOR dan rotasi bit, dan dapat diselesaikan sepenuhnya melalui analisis assembly dan pembalikan transformasi.

4. Smart Toaster TBF1{moM_1o0k_1M_A_HarDWare_H@cker_Now}
Sebuah smart toaster yang terhubung ke internet menolak beroperasi kecuali pengguna memasukkan license key yang valid. Firmware perangkat berhasil diperoleh dalam bentuk file firmware.elf. Tujuan challenge ini adalah menganalisis firmware tersebut untuk menemukan flag tersembunyi tanpa harus menjalankan firmware secara langsung di perangkat aslinya.
Langkah pertama adalah mengidentifikasi tipe dan arsitektur firmware menggunakan perintah readelf:
readelf -h firmware.elf
Outputnya:
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Atmel AVR 8-bit microcontroller
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          52 (bytes into file)
  Start of section headers:          10936 (bytes into file)
  Flags:                             0x5, avr:5
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         14
  Section header string table index: 11
Informasi ini menunjukkan bahwa firmware merupakan firmware embedded system berbasis AVR, sehingga analisis lanjutan perlu menggunakan tool khusus AVR seperti avr-objdump.

Langkah kedua, Setelah mengetahui jenis firmware, langkah selanjutnya adalah mencari simbol yang berkaitan dengan flag. Hal ini dilakukan menggunakan perintah nm:
nm firmware.elf | grep encrypted_flag
Outputnya: 00800100 D encrypted_flag
Hal ini mengindikasikan bahwa flag telah disimpan langsung di dalam firmware dalam bentuk data global, namun masih dalam keadaan terenkripsi.

Langkah ketiga, Karena encrypted_flag berada di section .data, langkah berikutnya adalah melakukan dump isi section tersebut menggunakan avr-objdump:
avr-objdump -s -j .data firmware.elf
Outputnya:
Contents of section .data:
 800100 f1e7e394 dec8cae8 fa94ca95 cefa94e8
 800110 fae4faed c4d7e1f2 c4d7c0fa ede5c6ce
 800120 c0d7faeb cad2d800
Byte-byte tersebut dimulai tepat dari alamat 0x800100, sesuai dengan alamat simbol encrypted_flag. Data tidak dapat dibaca sebagai ASCII dan diakhiri dengan byte 00, yang menandakan sebuah null-terminated string.
Dengan demikian, dapat dipastikan bahwa data tersebut adalah flag yang telah dienkripsi.

Langkah keempat, lakukan analisis skema enkripsi. Berdasarkan karakteristik tersebut, besar kemungkinan enkripsi yang digunakan adalah XOR satu byte, yang merupakan metode enkripsi sederhana dan sering digunakan pada challenge CTF embedded.
Untuk mendekripsi flag, dilakukan bruteforce XOR untuk seluruh kemungkinan key 1 byte (0x00–0xFF) menggunakan Python. Hasil dekripsi kemudian difilter agar hanya menampilkan karakter ASCII yang dapat dibaca.
script python untuk decrypt:
enc = bytes.fromhex(
    "f1e7e394dec8cae8fa94ca95cefa94e8"
    "fae4faedc4d7e1f2c4d7c0faede5c6ce"
    "c0d7faebcad2d8"
)

for k in range(256):
    dec = bytes(b ^ k for b in enc)
    if all(32 <= c < 127 for c in dec):
        print(hex(k), dec)
Script Python ini digunakan untuk mendekripsi data encrypted_flag yang diduga dienkripsi menggunakan XOR satu byte, dengan cara mencoba seluruh kemungkinan kunci XOR (0–255) dan menampilkan hasil yang masuk akal (berupa teks ASCII yang dapat dibaca)
didapatkan flagnya TBF1{moM_1o0k_1M_A_HarDWare_H@cker_Now}

5. The Stone Guardian
Diberikan sebuah gambar dan kita disuruh untuk menebak apa nama dari wahana pada gambar tersebut
 
